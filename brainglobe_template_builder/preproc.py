from itertools import product
from typing import Literal, Union

import numpy as np
from scipy.ndimage import affine_transform
from skimage import filters, measure, morphology


def _extract_largest_object(binary_image):
    """Keep only the largest object in a binary image.

    Parameters
    ----------
    binary_image : np.ndarray
        A binary image.

    Returns
    -------
    np.ndarray
        A binary image containing only the largest object.
    """
    labeled_image = measure.label(binary_image)
    regions = measure.regionprops(labeled_image)
    largest_region = max(regions, key=lambda region: region.area)
    return labeled_image == largest_region.label


def _threshold_image(
    image: np.ndarray,
    method: Literal["triangle", "otsu", "isodata"] = "triangle",
) -> Union[np.ndarray, None]:
    """Threshold an image using the specified method to get a binary mask.

    Parameters
    ----------
    image : np.ndarray
        Image to threshold.
    method : str
        Thresholding method to use. One of 'triangle', 'otsu', and 'isodata'
        (corresponding to methods from the skimage.filters module).
        Defaults to 'triangle'.

    Returns
    -------
    np.ndarray
        A binary mask.
    """

    method_to_func = {
        "triangle": filters.threshold_triangle,
        "otsu": filters.threshold_otsu,
        "isodata": filters.threshold_isodata,
    }
    if method in method_to_func.keys():
        thresholded = method_to_func[method](image)
        return image > thresholded
    else:
        raise ValueError(f"Unknown thresholding method {method}")


def create_mask(
    image: np.ndarray,
    gauss_sigma: float = 3,
    threshold_method: Literal["triangle", "otsu", "isodata"] = "triangle",
    closing_size: int = 5,
) -> np.ndarray:
    """Threshold image and create a mask for the largest object.

    The mask is generated by applying a Gaussian filter to the image,
    thresholding the smoothed image, keeping only the largest object, and
    applying a binary closing operation to the mask.

    Parameters
    ----------
    image : np.ndarray
        A 3D image to generate the mask from.
    gauss_sigma : float
        Standard deviation for Gaussian kernel (in pixels) to smooth image
        before thresholding. Set to 0 to skip smoothing.
    threshold_method : str
        Thresholding method to use. One of 'triangle', 'otsu', and 'isodata'
        (corresponding to methods from the skimage.filters module).
        Defaults to 'triangle'.
    closing_size : int
        Size of the binary closing footprint (in pixels) to apply to the mask.
        Set to 0 to skip closing. This is useful to remove small holes in the
        mask. Larger values will remove larger holes.

    Returns
    -------
    mask : np.ndarray
        A binary mask of the largest object in the image.
    """

    # Check input
    if image.ndim != 3:
        raise ValueError("Image must be 3D")

    if gauss_sigma > 0:
        data_smoothed = filters.gaussian(image, sigma=gauss_sigma)
    else:
        data_smoothed = image

    binary = _threshold_image(data_smoothed, method=threshold_method)
    mask = _extract_largest_object(binary)

    if closing_size > 0:
        mask = morphology.binary_closing(
            mask, footprint=np.ones((closing_size,) * image.ndim)
        )
    return mask


def get_midline_points(mask: np.ndarray):
    """Get a set of 9 points roughly on the x axis midline of a 3D binary mask.

    Parameters
    ----------
    mask : np.ndarray
        A binary mask of shape (z, y, x).

    Returns
    -------
    np.ndarray
        An array of shape (9, 3) containing the midline points.
    """

    # Check input
    if mask.ndim != 3:
        raise ValueError("Mask must be 3D")

    try:
        mask = mask.astype(bool)
    except ValueError:
        raise ValueError("Mask must be binary")

    # Derive mask properties
    props = measure.regionprops(measure.label(mask))[0]
    # bbox in shape (3, 2): for each dim (row) the min and max (col)
    bbox = np.array(props.bbox).reshape(2, 3).T
    bbox_ranges = bbox[:, 1] - bbox[:, 0]
    # mask centroid in shape (3,)
    centroid = np.array(props.centroid)

    # Find slices at 1/4, 2/4, and 3/4 of the z and y dimensions
    z_slices = [bbox_ranges[0] / 4 * i for i in [1, 2, 3]]
    y_slices = [bbox_ranges[1] / 4 * i for i in [1, 2, 3]]
    # Find points at the intersection the centroid's x slice
    # with the above y and z slices.
    # This produces a set of 9 points roughly on the midline
    points = list(product(z_slices, y_slices, [centroid[2]]))

    return np.array(points)


def _fit_plane_to_points(
    points: np.ndarray,
) -> tuple[np.ndarray, np.ndarray]:
    """Fit a plane to a set of 3D points.

    Parameters
    ----------
    points : np.ndarray
        An array of shape (n_points, 3) containing the points.

    Returns
    -------
    centroid : np.ndarray
        The centroid of the points.
    normal_vector : np.ndarray
        A vector normal to the fitted plane.
    """

    # Find the centroid of the points
    centroid = np.mean(points, axis=0)
    # Use SVD to get the normal vector to the plane
    _, _, vh = np.linalg.svd(points - centroid)
    normal_vector = vh[-1]

    return centroid, normal_vector


def _rotation_matrix_from_vectors(vec1: np.ndarray, vec2: np.ndarray):
    """Find the rotation matrix that aligns vec1 to vec2. Implementation
    adapted from StackOverflow [1]_.

    Parameters
    ----------
    vec1 : np.ndarray
        The 3D "source" vector
    vec2 : np.ndarray
        The 3D "target" vector

    Returns
    -------
    A rotation matrix (3x3) that, when applied to vec1, aligns it with vec2.

    References
    ----------
    .. [1] https://stackoverflow.com/questions/45142959
    """
    a = (vec1 / np.linalg.norm(vec1)).reshape(3)
    b = (vec2 / np.linalg.norm(vec2)).reshape(3)
    v = np.cross(a, b)
    c = np.dot(a, b)
    s = np.linalg.norm(v)
    kmat = np.array([[0, -v[2], v[1]], [v[2], 0, -v[0]], [-v[1], v[0], 0]])
    rotation_matrix = np.eye(3) + kmat + kmat.dot(kmat) * ((1 - c) / (s**2))
    return rotation_matrix


def get_alignment_transform(
    image: np.ndarray,
    points: np.ndarray,
    axis: Literal["x", "y", "z"] = "x",
) -> np.ndarray:
    """Find the transformation matrix that aligns the plane defined by the
    given points to the midline of the specified axis.

    Parameters
    ----------
    image : np.ndarray
        A 3D image to align.
    points : np.ndarray
        An array of shape (n_points, 3) containing points.
    axis : str
        Axis to align the midline with. One of 'x', 'y', and 'z'.
        Defaults to 'x'. The axis order is zyx in napari.

    Returns
    -------
    transform: np.ndarray
        A 4x4 rigid transformation matrix (3x3 rotation matrix with a 3x1
        translation vector appended to the right).
    """

    # Check input
    if image.ndim != 3:
        raise ValueError("Image must be 3D")
    if points.ndim != 2 or points.shape[1] != 3:
        raise ValueError("Points must be an array of shape (n_points, 3)")
    if axis not in ["x", "y", "z"]:
        raise ValueError("Axis must be one of 'x', 'y', or 'z'")

    # Fit a plane to the points
    centroid, normal_vector = _fit_plane_to_points(points)
    # invert the normal vector if it points in the opposite direction of the
    # specified axis
    axis_index = {"z": 0, "y": 1, "x": 2}[axis]  # axis order is zyx in napari
    axis_vector = np.zeros(3)
    axis_vector[axis_index] = 1
    if np.dot(normal_vector, axis_vector) < 0:
        normal_vector = -normal_vector

    # Find rotation to align the fitted plane (i.e. its normal vector)
    # with the specified axis (i.e. the axis unit vector)
    rotation_matrix = _rotation_matrix_from_vectors(normal_vector, axis_vector)
    # Find offset to bring the centroid to the middle of the specified axis
    mid_axis = image.shape[axis_index] // 2
    offset = mid_axis - centroid[axis_index]

    # Construct the transformation matrix by combining rotation and offset
    transform = np.zeros((4, 4))
    transform[:3, :3] = rotation_matrix
    transform[:3, 3] = offset * axis_vector
    return transform


def apply_transform(
    data: np.ndarray,
    transform: np.ndarray,
) -> np.ndarray:
    """Apply a rigid transformation to an image.

    Parameters
    ----------
    data : np.ndarray
        A 3D image to transform.
    transform : np.ndarray
        A 4x4 transformation matrix.

    Returns
    -------
    np.ndarray
        The transformed data.

    Notes
    -----
    This function inverts the affine and flips the offset when passing the data
    to `scipy.ndimage.affine_transform`. This is because the transforms are
    given in the 'push' (or 'forward') direction, transforming input to output,
    whereas `scipy.ndimage.affine_transform` does `pull` (or `backward`)
    resampling, transforming the output space to the input.
    """

    if data.ndim != 3:
        raise ValueError("Data must be 3D")
    if transform.shape != (4, 4):
        raise ValueError("Transform must be a 4x4 matrix")

    # use larger output shape (to avoid cropping of edges)
    output_shape = [int(1.1 * s) for s in data.shape]

    transformed = affine_transform(
        data,
        np.linalg.inv(transform[:3, :3]),
        offset=-transform[:3, 3],
        output_shape=output_shape,
    )
    return transformed
